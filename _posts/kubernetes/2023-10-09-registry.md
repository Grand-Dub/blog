---
title: REGISTRY pour Docker & Kubernetes
date: 2023-10-18
categories: 
  - Kubernetes
  - Docker
layout: post
description: "Techniques pour faire un Registry de containers via docker-compose avec ou sans TLS et/ou authentification via un classique htpasswd. En conclusion, configurer Kubernetes pour la confiance en des AC privés !"
---

Ici, nous allons faire un un *registry* de *containers* via un fichier *docker-compose*.  
Dans ce *docker-compose*, il y aura les directives pour la communication *HTTPS* et une authentification via *htpasswd* (*basic authentication*). Ces directives ne sont pas obligatoires pour le bon fonctionnement du *registry*.  
Si nous voulons une communication *HTTPS* entre *docker* et un *registry* privé, il faut que *docker* ait confiance en une AC privée (ou, ici, un certificat auto-signé). Nous verrons comment faire.   
Enfin, comme *Kubernetes* exige que le *registry* soit en *HTTPS*, nous allons faire un *playbook ansible* qui permet d'avoir confiance dans notre AC privée avec une spécification *yaml* équivalente au *docker-compose*.


Création d'un certificat auto-signé avec **SAN** en utilisant *openssl*
=======================================================================

Pour un *registry* public, on peut toujours acheter un certificat ou utiliser *letsencrypt* (par exemple via pfSense+HA-Proxy, ce sera l'objet d'un futur article).  
Mais dans un contexte interne et privée, voici un un exemple de certificat valable 100 ans.

> A partir d'ici, on considère que l'adresse IP de l'hôte *Docker* est **172.22.22.1**  
{: .block-tip }

```sh
openssl req -nodes -x509 -sha256 -newkey rsa:4096 \
  -keyout server.key \
  -out server.crt \
  -days 35600 \
  -subj "/C=FR/ST=Loire Atlantique/L=Nantes/O=IASC/OU=Infrastructure/CN=Grand Dub"  \
  -addext "subjectAltName = DNS: granddub.lan, IP: 172.22.22.1" 
```

> `-newkey` peut être `ED25519` mais la version du *registry* utilisée, `2.7.1`, le jour de ce test ne comprend apparemment pas cet algorithme !  
{: .block-tip }

> **Vérification du contenu du certificat**
```sh
openssl x509 -text -noout -in server.crt
```


Configurer *docker* pour avoir confiance dans une AC privée
=========================================================

Ici, il s'agit du certificat auto-signé créé précédemment.

- créer le répertoire `/etc/docker/certs.d/172.22.22.1:5000/`
- y copier le fichier `server.crt`

> Inutile de redémarrer le daemon *docker*
{: .block-tip }

Authentification dans le *registry* avec *local basic authentication*
=====================================================================

source: <https://docs.docker.com/registry/deploying/#native-basic-auth>{:target="_blank"}  
On peut aussi s'authentifier avec *LDAP*, *OAUTH*... (voir la documentation)  

Nous allons créer un fichier *htpasswd* local puis l'utiliser dans le *docker-compose*. Il faut bien sûr installer l'utilitaire *htpasswd* (il est dans le dépôt *Linux* classique: *apache2-utils* (du moins sur une distribution à base de *Debian*)).  

```sh
htpasswd -Bbn granddub 'Pa$$w0rd' > htpasswd
```

*docker-compose* d'un *registry* avec *HTTPS*, authentification avec *htpasswd* et interface Web de gestion
===========================================================================================================

Ici, on utilise les fichiers créés précédemment.  
La version de l'image *registry* est à adapter selon les besoins **(et donc à tester)**.  

Tout est inspiré de <https://github.com/Joxit/docker-registry-ui>{:target="_blank"}  

```yaml
version: "3.5"

volumes:
  registry-volume: # stockage des images et des métadonnées                                                                   
    name: registry-volume

services:
  registry:
    image: registry:2.8.2
    ports:
      - 5000:5000
    restart: always
    volumes:
      - registry-volume:/var/lib/registry
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro

      - ./config.yml:/etc/docker/registry/config.yml:ro # configuration modifiée                                              
      - ./server.crt:/cert/server.crt:ro # certificat pour HTTPS                                                              
      - ./server.key:/cert/server.key:ro # clef privée associée                                                               
      - ./htpasswd:/etc/docker/registry/htpasswd:ro # base de comptes utilisateurs                                            

  gui:
    image: joxit/docker-registry-ui:2.5.5
    ports:
      - 80:80
    restart: always
    depends_on:
      - registry
    volumes:
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    environment:
      - SINGLE_REGISTRY=true # pour ne pas avoir à configurer la page de browsing                                             
      - REGISTRY_TITLE=Docker Registry UI
      - DELETE_IMAGES=true
      - SHOW_CONTENT_DIGEST=true
      - NGINX_PROXY_PASS_URL=https://registry:5000
      - CATALOG_MIN_BRANCHES=1
      - CATALOG_MAX_BRANCHES=1
      - TAGLIST_PAGE_SIZE=100
      - REGISTRY_SECURED=true # pour Basic Authentication                                                                     
      - CATALOG_ELEMENTS_LIMIT=1000
      - SHOW_CATALOG_NB_TAGS=true # déconseillé sur les gros Registry (génère une requête supplémentaire par tag d'image)     
      - HISTORY_CUSTOM_LABELS=true
```

> ***config.yml***  

```yaml
# version originale de la version 2.7.1 avec modifications indiquées

version: 0.1
log:
  fields:
    service: registry
storage:
  cache:
    blobdescriptor: inmemory
  filesystem:
    rootdirectory: /var/lib/registry
#modification: 2 lignes
  delete:
    enabled: true
http:
  addr: :5000
  headers:
    X-Content-Type-Options: [nosniff]
    #modifications: 5 lignes -> CORS '*' pour joxit/docker-registry-ui par exemple
    Access-Control-Allow-Origin: ['*']
    Access-Control-Allow-Headers: ['Authorization', 'Accept']
    Access-Control-Allow-Methods: ['HEAD', 'GET', 'OPTIONS', 'DELETE']
    Access-Control-Expose-Headers: ['Docker-Content-Digest']
    Access-Control-Allow-Credentials: [true] # autorise l'authentification mais incompatible avec Access-Control-Allow-Origin à '*' avec fetch() (à creuser)
  #modifications: 3 lignes -> https
  tls:
    certificate: /cert/server.crt
    key: /cert/server.key

health:
  storagedriver:
    enabled: true
    interval: 10s
    threshold: 3

```

> On peut tester le *registry* sans utiliser l'interface Web avec:
> ```sh
> curl 'https://granddub:Pa$$w0rd@172.22.22.1:5000/v2/' -kI
> # doit retourner HTTP 200 et:
> curl 'https://granddub:pwd@172.22.22.1:5000/v2/' -kI
> # doit retourner HTTP 401 car le mot de passe est erroné
> ```
{: .block-tip }

> **DELETE**  
> 
> via l'API cela ne supprime que les métadonnées!  
> 
> Pour supprimer le stockage:  
> - être idéalement en lecture seule sur le service (comment ?)  
> - `/bin/registry garbage-collect /etc/docker/registry/config.yml`  
> - après suppression du dernier tag d'un repo:  
>   - supprimer physiquement le repo (son nom) dans `/var/lib/registry/docker/registry/v2/repositories/`  
> - redémarrer le container (sinon le stockage est bien supprimé mais le service croit qu'il existe toujours)  
{: .block-warning }
